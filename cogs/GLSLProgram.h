#ifndef GLSLPROGRAM_H
#define GLSLPROGRAM_H

#include "ShaderData.h"

#include <glm\mat4x4.hpp>
#include <map>
#include <memory>

namespace cogs
{
		namespace graphics
		{
				/** This class handles the compilation, linking, and usage of a GLSL shader program. */
				class GLSLProgram
				{
				public:
						GLSLProgram();
						GLSLProgram(const std::string& _name, const std::string& _vsFilePath, const std::string& _fsFilePath, const std::string& _gsFilePath = "");
						~GLSLProgram();

						/**
								* \brief Compiles the passed shaders
								* \param[in] _shaders The shaders passed to the main program in order to be compiled
								*/
						void compileShaders(const std::string& _name, const std::string& _vsFilePath, const std::string& _fsFilePath, const std::string& _gsFilePath = "");

						/**
								* \brief Compiling vertex and fragment shaders from source
								* \param[in] _vertexSource, _fragmentSource the source code of the vertex and fragment shader
								*/
						void compileShadersFromSource(const char* _vertexSource, const char* _fragmentSource, const char* _geometrySource = nullptr);

						/**
								* \brief Returns the index of the named uniform block specified by uniformBlockName associated with the shader program.
								* If uniformBlockName is not a valid uniform block of the shader program, GL_INVALID_INDEX is returned
								* \param[in] _uniformBlockName The name of the requested uniform block
								* \return output is the GLint location of the uniform block in the shader
								*/
						GLuint getUniformBlockIndex(const std::string& _uniformBlockName);

						/**
								* \brief Returns the size of the block as generated by the compiler
								* \param[in] _index The index of the uniform block (Gotten from GetUniformBlockIndex)
								* \param[out] _params The GLint locations array of parameters in the specific uniform block
								*/
						void getUniformBlockDataSize(GLuint _index, GLint* _params);

						/**
								* \brief Returns the indices associated with the uniformCount uniform variables specified by name in the array uniformNames
								* in the array uniformIndices for this shader program
								* \param[in] _numUniforms The number of uniforms in an Uniform block
								* \param[in] _uniformNames The names of the uniform variables inside the uniform block
								* \param[out] _uniformIndices The outputted indices of the associated uniform variables
								*/
						void getUniformIndices(GLsizei _numUniforms, const char ** _uniformNames, GLuint * _uniformIndices);

						/**
								* \brief Associate a buffer object with a specific uniform block
								*  If all the buffer storage is used for the uniform block, set offset to 0 and size to size of the buffer (equivalent to glBindBufferBase()).
								* \param[in] _target The target can either be GL_UNIFORM_BUFFER (for uniform blocks) or GL_TRANSFORM_FEEDBACK_BUFFER (for use with transform feedback)
								* \param[in] _index The index of the uniform block (Gotten from GetUniformBlockIndex)
								* \param[out] _buffer The buffer object that will get associated with the specific uniform block (index)
								* \param[in] _offset The specification of the starting index (can be 0 if the index is the starting one)
								* \param[in] _size The range of the buffer that is to be mapped to the uniform buffer. (can be the size of the buffer object)
								*/
						void bindBufferRange(GLenum _target, GLuint _index, GLuint _buffer, GLintptr _offset, GLsizeiptr _size);

						/**
								* \brief Explicitly assigns uniformBlockIndex to uniformBlockBinding for the current shader program program.
								* Use when a specific uniform block is used in many shader programs, so that it avoids having the block be assigned a different index for each program
								* Must be called before calling LinkShaders
								* \param[in] _uniformBlockIndex The index that the uniform block will be assigned to
								* \param[in] _uniformBlockBinding The uniform block that will be explicitly bound to the uniformBlockIndex
								*/
						void blockUniformBinding(GLuint _uniformBlockIndex, GLuint _uniformBlockBinding);

						/**
								* \brief This function is used to get the offset, size and type of for an index of an Uniform block.
								* \param[in] _numUniforms The number of uniform variables in an Uniform block
								* \param[in] _uniformIndices The indices of the associated uniform variables
								* \param[in] _pname The possible enums: GL_UNIFORM_OFFSET, GL_UNIFORM_SIZE, GL_UNIFORM_TYPE (they specify the outputted attribute)
								* \param[out] _attribute The outputted attribute
								*/
						void getActiveUniformsIndexValues(GLsizei _numUniforms, GLuint * _uniformIndices, GLenum _pname, GLint * _attribute);

						/**
								* \brief Returns the location of the subroutine uniform named _name in the current shader program object for the shading stage specified by _shaderType.
								* \param[in] _shaderType Must be one of: GL_VERTEX_SHADER, GL_FRAGMENT_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, or GL_GEOMETRY_SHADER.
								* \param[in] _name The name of the uniform variable (null-terminated cstring
								* \return the location of the subroutine uniform named _name
								*/
						GLint getSubroutineUniformLocation(GLenum _shaderType, const std::string& _name);

						/**
								* \brief Determine the indices of the subroutines inside the shader
								* \param[in] _shaderType Must be one of: GL_VERTEX_SHADER, GL_FRAGMENT_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, or GL_GEOMETRY_SHADER.
								* \param[in] _name The name of the uniform variable (null-terminated cstring
								* \return the index of the shader function associated with _name from current shader program for the shading stage specified by _shaderType
								*/
						GLuint getSubroutineIndex(GLenum _shaderType, const std::string& _name);

						/**
								* \brief Specify which subroutine should be executed in the shader. All active subroutine uniforms for a shader stage must be initialized.
								* \param[in] _shaderType Must be one of: GL_VERTEX_SHADER, GL_FRAGMENT_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, or GL_GEOMETRY_SHADER.
								* \param[in] _numSubrUniforms The number of subroutine uniforms
								* \param[in] _indices The values which the shader subroutine uniforms are set to. The i'th subroutine uniform will be assigned the value indices[i].
								*/
						void uniformSubroutinesuiv(GLenum _shaderType, GLsizei _numSubrUniforms, const GLuint * _indices);

						/** Begin using the shader*/
						void use();

						/** Stop using the shader*/
						void unUse();

						/** Dispose of the shader*/
						void dispose();

						/* Registers the location of an attribute in this shader (must be called after linking) */
						void registerAttribute(const std::string& _attrib);

						/* Registers the location of a uniform in this shader (must be called after linking) */
						void registerUniform(const std::string& _uniform);

						//accesses elements : attributes/uniforms;
						AttribLocation getAttribLocation(const std::string& _attrib);
						UniformLocation getUniformLocation(const std::string& _uniform);

						/* Upload values to the shader */
						void uploadValue(const std::string& _uniformName, const glm::mat4& _matrix);
						void uploadValue(const std::string& _uniformName, const float& _float);
						void uploadValue(const std::string& _uniformName, const int& _int);
						void uploadValue(const std::string& _uniformName, const glm::vec2& _vec2);
						void uploadValue(const std::string& _uniformName, const glm::vec3& _vec3);
						void uploadValue(const std::string& _uniformName, const glm::vec4& _vec4);

				private:
						/* Compile a single shader program */
						void compileShader(const char* _source, const std::string& _name, GLuint _id);

						/** Links the shaders together */
						void linkShaders(ProgramID _programID, ShaderID _vertID, ShaderID _fragID, ShaderID _geoID = 0);

				private:
						static std::map<std::string, std::shared_ptr<ShaderData>> s_resourceMap;

						std::weak_ptr<ShaderData> m_shaderData;
						std::string m_programName{ "" };
				};
		}
}

#endif // !GLSLPROGRAM_H